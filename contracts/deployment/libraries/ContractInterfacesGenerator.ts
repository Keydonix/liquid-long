type Primitive = 'uint8' | 'uint64' | 'uint256' | 'bool' | 'string' | 'address' | 'bytes20' | 'bytes32' | 'bytes' | 'int256' | 'tuple' | 'address[]' | 'uint256[]' | 'bytes32[]' | 'tuple[]'

interface AbiParameter {
	name: string,
	type: Primitive,
	components?: Array<AbiParameter>
}

interface AbiEntry {
	type: string
}

interface AbiFunction extends AbiEntry {
	name: string,
	type: 'function',
	constant: boolean,
	payable: boolean,
	inputs: Array<AbiParameter>,
	outputs: Array<AbiParameter>,
}

type Abi = Array<AbiEntry>

interface CompilerOutput {
	contracts: {
		[globalName: string]: {
			[contractName: string]: {
				abi: Abi
			}
		}
	}
}

export class ContractInterfaceGenerator {
	public generateContractInterfaces(contractsOutput: CompilerOutput): string {
		const contractInterfaces: Array<string> = []

		for (let globalName in contractsOutput.contracts) {
			for (let contractName in contractsOutput.contracts[globalName]) {
				const contractAbi: Abi = contractsOutput.contracts[globalName][contractName].abi
				if (contractAbi.length == 0) continue
				contractInterfaces.push(this.contractInterfaceTemplate(contractName, contractAbi))
			}
		}

		return `// THIS FILE IS AUTOMATICALLY GENERATED BY \`generateContractInterfaces.ts\`. DO NOT EDIT BY HAND'

export type Primitive = 'uint8' | 'uint64' | 'uint256' | 'bool' | 'string' | 'address' | 'bytes20' | 'bytes32' | 'bytes' | 'int256' | 'tuple' | 'address[]' | 'uint256[]' | 'bytes32[]' | 'tuple[]'

export interface AbiParameter {
	name: string,
	type: Primitive,
	components?: Array<AbiParameter>
}

export interface AbiEventParameter extends AbiParameter {
	indexed: boolean,
}

export interface AbiFunction {
	name: string,
	type: 'function' | 'constructor' | 'fallback',
	stateMutability: 'pure' | 'view' | 'payable' | 'nonpayable',
	constant: boolean,
	payable: boolean,
	inputs: Array<AbiParameter>,
	outputs: Array<AbiParameter>,
}

export interface AbiEvent {
	name: string,
	type: 'event',
	inputs: Array<AbiEventParameter>,
	anonymous: boolean,
}

export type Abi = Array<AbiFunction | AbiEvent>

export interface Transaction <TBigNumber> {
	to: string
	from: string
	data: string
	value?: TBigNumber
}

export interface TransactionReceipt {
	status: number
}

export interface Dependencies<TBigNumber> {
	// TODO: get rid of some of these dependencies in favor of baked in solutions
	keccak256(utf8String: string): string
	encodeParams(abi: AbiFunction, parameters: Array<any>): string
	decodeParams(abi: Array<AbiParameter>, encoded: string): Array<any>
	getDefaultAddress(): Promise<string>
	call(transaction: Transaction<TBigNumber>): Promise<string>
	estimateGas(transaction: Transaction<TBigNumber>): Promise<TBigNumber>
	signTransaction(transaction: Transaction<TBigNumber>): Promise<string>
	sendSignedTransaction(signedTransaction: string): Promise<TransactionReceipt>
}


/**
 * By convention, pure/view methods have a \`_\` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a localy version and a remote version (distinguished by the trailing \`_\`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract<TBigNumber> {
	protected readonly dependencies: Dependencies<TBigNumber>
	public readonly address: string
	protected readonly defaultGasPrice: TBigNumber

	protected constructor(dependencies: Dependencies<TBigNumber>, address: string, defaultGasPrice: TBigNumber) {
		this.dependencies = dependencies
		this.address = address
		this.defaultGasPrice = defaultGasPrice
	}

	private stringifyParams(params: Array<AbiParameter>): Array<string> {
		return params.map(param => {
			if (param.type === 'tuple') {
				if (!param.components) throw new Error(\`Expected components when type is \${param.type}\`)
				return \`(\${this.stringifyParams(param.components).join(',')})\`
			} else if (param.type === 'tuple[]') {
				if (!param.components) throw new Error(\`Expected components when type is \${param.type}\`)
				return \`(\${this.stringifyParams(param.components).join(',')})[]\`
			} else {
				return param.type
			}
		})
	}

	private hashSignature(abiFunction: AbiFunction): string {
		const parameters = this.stringifyParams(abiFunction.inputs).join(',')
		const signature = \`\${abiFunction.name}(\${parameters})\`
		return this.dependencies.keccak256(signature).substring(0, 10)
	}

	private encodeMethod(abi: AbiFunction, parameters: Array<any>) {
		return \`\${this.hashSignature(abi)}\${this.dependencies.encodeParams(abi, parameters)}\`
	}

	protected async localCall(abi: AbiFunction, parameters: Array<any>, sender?: string, attachedEth?: TBigNumber): Promise<any> {
		const from = sender || await this.dependencies.getDefaultAddress()
		const data = this.encodeMethod(abi, parameters)
		const transaction = Object.assign({ from: from, to: this.address, data: data }, attachedEth ? { value: attachedEth } : {})
		const result = await this.dependencies.call(transaction)
		if (result === '0x') throw new Error(\`Call returned '0x' indicating failure.\`)
		return this.dependencies.decodeParams(abi.outputs, result)
	}

	protected async remoteCall(abi: AbiFunction, parameters: Array<any>, txName: String, sender?: string, gasPrice?: TBigNumber, attachedEth?: TBigNumber): Promise<void> {
		const from = sender || await this.dependencies.getDefaultAddress()
		const data = this.encodeMethod(abi, parameters)
		const gasEstimate = await this.dependencies.estimateGas(Object.assign({ to: this.address, from: from, data: data }, attachedEth ? { value: attachedEth } : {} ))
		gasPrice = gasPrice || this.defaultGasPrice
		const transaction = Object.assign({ from: from, to: this.address, data: data, gasPrice: gasPrice, gas: gasEstimate }, attachedEth ? { value: attachedEth } : {})
		const signedTransaction = await this.dependencies.signTransaction(transaction)
		const transactionReceipt = await this.dependencies.sendSignedTransaction(signedTransaction)
		if (transactionReceipt.status != 1) {
			throw new Error(\`Tx \${txName} failed: \${transactionReceipt}\`)
		}
	}
}

${contractInterfaces.join('\n')}
`
	}

	private contractInterfaceTemplate(contractName: String, contractAbi: Abi) {
		const contractMethods: Array<String> = []

		// FIXME: Add support for Solidity function overloads.  Right now overloaded functions are not supported, only the first one seen will servive addition into the following set.
		const seen: Set<string> = new Set()

		const contractFunctions: Array<AbiFunction> = contractAbi
			.filter(abiEntry => abiEntry.type == 'function')
			.map(abiFunction => <AbiFunction>abiFunction)

		for (let abiFunction of contractFunctions) {
			if (seen.has(abiFunction.name)) continue
			if (!abiFunction.constant) {
				contractMethods.push(this.remoteMethodTemplate(abiFunction))
			}
			contractMethods.push(this.localMethodTemplate(abiFunction))
			seen.add(abiFunction.name)
		}

		return `
export class ${contractName}<TBigNumber> extends Contract<TBigNumber> {
	public constructor(dependencies: Dependencies<TBigNumber>, address: string, defaultGasPrice: TBigNumber) {
		super(dependencies, address, defaultGasPrice)
	}

${contractMethods.join('\n\n')}
}
`
	}

	private remoteMethodTemplate(abiFunction: AbiFunction) {
		const argNames: String = this.toArgNameString(abiFunction)
		const params: String = this.toParamsString(abiFunction)
		const options: String = `{ sender?: string, gasPrice?: TBigNumber${abiFunction.payable ? ', attachedEth?: TBigNumber' : ''} }`
		return `	public ${abiFunction.name} = async(${params}options?: ${options}): Promise<void> => {
		options = options || {}
		const abi: AbiFunction = ${JSON.stringify(abiFunction)}
		await this.remoteCall(abi, [${argNames}], '${abiFunction.name}', options.sender, options.gasPrice${abiFunction.payable ? ', options.attachedEth' : ''})
		return
	}`
	}

	private localMethodTemplate(abiFunction: AbiFunction) {
		const argNames: String = this.toArgNameString(abiFunction)
		const params: String = this.toParamsString(abiFunction)
		const options: String = `{ sender?: string${abiFunction.payable ? ', attachedEth?: TBigNumber' : ''} }`
		const returnType: String = this.toTsReturnTypeString(abiFunction.outputs)
		const returnPromiseType: String = returnType
		const returnValue: String = (abiFunction.outputs.length === 1)
			? `<${returnType}>result[0]`
			: `<${returnType}>result`
		return `	public ${abiFunction.name}_ = async(${params}options?: ${options}): Promise<${returnPromiseType}> => {
		options = options || {}
		const abi: AbiFunction = ${JSON.stringify(abiFunction)}
		${abiFunction.outputs.length !== 0 ? 'const result = ' : ''}await this.localCall(abi, [${argNames}], options.sender${abiFunction.payable ? ', options.attachedEth' : ''})${abiFunction.outputs.length !== 0 ? `\n\t\treturn ${returnValue}` : ''}
	}`
	}

	private toTsReturnTypeString(abiParameters: AbiParameter[]): string {
		if (abiParameters.length === 0) return `void`
		else if (abiParameters.length === 1) return this.toTsTypeString(abiParameters[0])
		else if (!abiParameters.every(abiParameter => !!abiParameter.name)) throw new Error(`Functions with multiple return values must name them all.`)
		else return `{${abiParameters.map(abiParameter => `${abiParameter.name}: ${this.toTsTypeString(abiParameter)}`).join(', ')}}`
	}

	private toTsTypeString(abiParameter: AbiParameter): string {
		switch(abiParameter.type) {
			case 'uint8':
			case 'uint64':
			case 'uint256':
			case 'int256': {
				return 'TBigNumber'
			}
			case 'string':
			case 'address':
			case 'bytes20':
			case 'bytes32':
			case 'bytes': {
				return 'string'
			}
			case 'bool': {
				return 'boolean'
			}
			case 'tuple': {
				return `{ ${abiParameter.components!.map(component => `${component.name}: ${this.toTsTypeString(component)}`).join(', ')} }`
			}
			case 'address[]': {
				return 'Array<string>'
			}
			case 'uint256[]': {
				return 'Array<TBigNumber>'
			}
			case 'bytes32[]': {
				return 'Array<string>'
			}
			case 'tuple[]': {
				return `Array<{ ${abiParameter.components!.map(component => `${component.name}: ${this.toTsTypeString(component)}`).join(', ')} }>`
			}
			default: {
				throw new Error(`Unrecognized Value: ${abiParameter}`)
			}
		}
	}

	private toArgNameString(abiFunction: AbiFunction) {
		return abiFunction.inputs.map(this.toParamNameString).join(', ')
	}

	private toParamsString(abiFunction: AbiFunction) {
		if (abiFunction.inputs.length == 0) return ''
		return abiFunction.inputs.map((abiParameter, i) => `${this.toParamNameString(abiParameter, i)}: ${this.toTsTypeString(abiParameter)}`).join(', ') + ', '
	}

	private toParamNameString(abiParameter: AbiParameter, index: number) {
		if (!abiParameter.name) return `arg${index}`
		else if (abiParameter.name.startsWith('_')) return abiParameter.name.substr(1)
		else return abiParameter.name
	}
}
